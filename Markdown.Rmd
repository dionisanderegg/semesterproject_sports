---
title: "Markdown"
author: "Alissa Tophinke, Dionis Anderegg"
date: "27 Mai 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

#1 Data Preparation 
## 1.1 Load packages

load Packages :
```{r, message = FALSE}
library(rgdal) 
library(sf)
library(tidyverse)
library(lubridate)
library(zoo)
library(purrr)
library(base)

if(!requireNamespace("remotes")) {
    install.packages("remotes")
}
remotes::install_github("grimbough/FITfileR")

library(FITfileR)
library(gdata)


```

## 1.2 Import data

Import all files with extension .fit from the R project folder and merge them into a single Data.frame. Delete all other Data.frames so that only the entire DF is in the workspace. Various calculations have to be done only once (timelag, distance etc.).



```{r message=TRUE, warning=FALSE}

myfiles <- list.files(".",pattern = "*.fit")

for (i in 1:length(myfiles)) {
  varName <- paste0("temp", i, ".fit")
  assign(varName, as.data.frame(records(readFitFile(myfiles[i]))))
}

#generate dataframe "full" with all data

full <- mget(ls(pattern="temp")) %>%
              bind_rows()

keep(full, sure = TRUE)

#check full
head(full)
```
## 1.3 evaluate altitude with DEM 

```{r}
#digital elevation model to verify altitude for each GPS location


if(!require(arc2r)){remotes::install_github("arc2r/arc2r")}

#R-script
#wird noch angepasst



```



## 1.4 add variables 

Calculate speed and timelags. Activities must be able to be grouped. This is done via the "activity_ID", which segments the data frame into individual tracks.
For the distance between two GPS fixes a SF object must be created and converted to the format CH1903+ LV95. From this the distance can be calculated.

### 1.4.1 calculate timelag

```{r}
# Timelag berechnen
full$timelag <- as.integer(difftime(full$timestamp, lag(full$timestamp)))
# Aktivitäts ID erstellen => Wichtig für Gruppieren etc.
full$activity_conter <- ifelse(abs(full$timelag) > 3600, TRUE, FALSE)   # Neue ID wenn mehr als 1 Stunde timelag
full$activity_conter[1] <- TRUE  # ID 1 = TRUE, da die dies die Aktivität Nummer 1 ist

full$activity_ID <- cumsum(full$activity_conter == TRUE)  # Erstellt die AktivitätsID basierend auf Conter

```

### 1.4.2 calculate speed
```{r}
# Geschwindigkeit von m/s in kmh
full$enhanced_speed_kmh <- full$enhanced_speed *3.6


# In SF umwandeln => Um die Euclidian distance zu berechnen, crs= 4326 -> RS used by Google Earth
full_sf <- st_as_sf(full, coords = c("position_long", "position_lat"),
         crs = 4326)

# Konvertieren zu CH1903+ LV95
full_sf <- st_transform(full_sf, crs = 2056)
options(digits = 3)

# N und E Koordinaten aus der Geometrie ziehen
full_sf$N <- st_coordinates(full_sf$geometry)[,1]
full_sf$E <- st_coordinates(full_sf$geometry)[,2]

# Euclidian steplength berechnen

full_sf <- full_sf %>%
  group_by(activity_ID) %>%
  mutate(
    steplength = sqrt((E - lead(E))^2 + (N - lead(N))^2),
    steplenght_sum = cumsum(replace_na(steplength,0)),
    hightdiff = lead(enhanced_altitude) - enhanced_altitude,
    hightdiff_up = ifelse(hightdiff > 0, hightdiff, 0),
    hightdiff_down = ifelse(hightdiff < 0, hightdiff, 0)
  )

#compare distance and steplength_sum

full_sf %>%
  filter(activity_ID == 5) %>%
  ggplot() +
  geom_point(aes(timestamp, distance), col = "blue") +
  geom_point(aes(timestamp, steplenght_sum), col = "red") +
  theme_bw() +
  labs(x = "\nUhrzeit in hh:mm", y = "Distanz in m\n")

#max. value distance / max value calculated steplength_sum
max(full_sf$distance) / max(full_sf$steplenght_sum) # close to 1 (0.988)

```
Die Grafik zeigt, dass die Distanz aus dem .fit-File sehr nahe an der berechneten Distanz liegt.
Die .fit-Datei gibt eine um 1.1 % tiefere Distanz an als die über die GPS-Fixes berechnete Distanz.
Weiter mit den Daten von der .fit Datei???

###1.4.3 Rolling window (smoothen)

```{r}

rolling_window_function <- function(smoothing_window){
  
  full_k <- mutate(full_long, movingwindow = rollmean(full_long$enhanced_speed, k=smoothing_window, fill=NA, align="left"))
  myplot <-ggplot(full_k)+
    geom_line(mapping = aes(x=timestamp, y=movingwindow, color=as.factor(activity_ID)))
  #print the plot
  print(myplot)

}

#try different k values (fenster)
smoothing_window_1 <- rolling_window_function(1) 
smoothing_window_2 <- rolling_window_function(2)
smoothing_window_4 <- rolling_window_function(4)
smoothing_window_6 <- rolling_window_function(6)

#Specify a temporal windows v for in which to measure Euclidean distance

```



# 2 Explorative data analysis 

Datenanalyse eines einzelnen Tracks

Folgend wird grafisch aufgezeigt, wie sich die Variablen Geschwindigkeit, Höhendifferenz und Herzfrequenz verhalten.
```{r}
full_long <- gather(full, type, value, enhanced_altitude:heart_rate, enhanced_speed_kmh)

full_long %>%
  filter(activity_ID == 1) %>%
  ggplot(aes(timestamp, value, col = type)) +
  geom_line()+
  geom_point() +
  facet_wrap(~type, scales = "free",ncol = 1) +
  theme_bw() +
  theme(legend.position = "none") +
  labs(x = "\nUhrzeit in hh:mm", y = "Wert\n")
```

In der Tendenz lässt sich visuell eine Abnahme der Geschwindigkeit und eine Zunahme der Herzfrequenz mit einem Höhenanstieg erkennen. Ausserdem ist eine Pause von ca. 10 minuten duetlich am Geschwindigkeitdiagramm zu erkennen.

# 3 Map visualizations

Tracks auf Karten darstellen (verschiedene Packages und Methoden). Welche Packages eignen sich?

## visualization without maps

ggplot:
```{r, message=FALSE}
# Visualisierung mit ggplot ohne Karte
library(tidyverse)
ggplot(filter(full, enhanced_speed_kmh > 4), aes (position_lat, position_long, col = enhanced_speed_kmh)) +
  geom_point() +
  facet_wrap(~activity_ID, scales = "free") +
  theme_bw()
```

Bei einigen Tracks scheint es noch ein Problem mit den Daten zu geben. = Siehe obiger Plot.

##visualization with leaflet

Leaflet ist interaktiv (m.E. sehr cool ;)) aber weniger einfach zu bearbeiten als ggplot oder ggmap (facets und einfärben von Datenpunkten etc.).
```{r, message = FALSE}
# Visualiseriung mit leaflet() => Interaktiv, schwer zu bearbeiten
library(leaflet)

# Track 1
m1 <- full %>%
  filter(activity_ID ==1) %>%
  select(position_long, position_lat) %>% 
  as.matrix() %>%
  leaflet(  ) %>%
  addTiles() %>%
  addPolylines( )
m1

# Track 2
m2 <- full %>%
  filter(activity_ID ==2) %>%
  select(position_long, position_lat) %>% 
  as.matrix() %>%
  leaflet(  ) %>%
  addTiles() %>%
  addPolylines( )
m2
```


ggmap() => Da die Karten importiert werden müssen nur für 3 Tracks gezeigt:
```{r, message = FALSE}
# Visualiserung mit ggmap
track1_3 <- full %>%
  filter(activity_ID < 4)

library(ggmap)

myLocation <- c(min(track1_3$position_long), min(track1_3$position_lat), 
                max(track1_3$position_long), max(track1_3$position_lat))  # Position definieren für Karten

myMap <- get_stamenmap(bbox=myLocation, maptype="terrain", crop=TRUE, zoom = 13)  # Kartenimport

ggmap(myMap) +
  geom_point(data = filter(track1_3, enhanced_speed_kmh > 3), 
             aes(position_long,position_lat, col = enhanced_speed_kmh)) +
  facet_wrap(~activity_ID) +
  labs(x = "\nLängengrad [°E]", y = "Breitengrad [°N]\n")
```


# 4 Zusammenfassung pro Track
```{r}
zf <- full_sf %>%
  st_drop_geometry() %>%
  group_by(activity_ID) %>%
  summarise(
    date = date(timestamp[1]),
    distance = max(distance, na.rm = TRUE),
    time = as.numeric(difftime(max(timestamp), min(timestamp), units = "mins")),
    hightdiff_up = sum(hightdiff_up, na.rm = TRUE),
    hightdiff_down = sum(hightdiff_down, na.rm = TRUE),
    mean_pace = time / distance * 1000
    )
```

# 5 Behaviour pattern

## 5.1 static / moving points

```{r}
#Remove “static points”

#Define threshold 
#choose a threshold between stops and moves --> depending on data and question!

# a) first try: mean value for a temporal window as a threshold


#make a temporal window v of 10 minutes, i.e. a window size of 10 positions (n±3).

tracks <- full_sf %>%
  mutate(
    nMinus5 = sqrt((lag(E,5)-E)^2+(lag(N,5)-N)^2),   # distance to pos -5 minutes
    nMinus4 = sqrt((lag(E,4)-E)^2+(lag(N,4)-N)^2),   # distance to pos -4 minutes
    nMinus3 = sqrt((lag(E,3)-E)^2+(lag(N,3)-N)^2),   # distance to pos -3 minutes
    nMinus2 = sqrt((lag(E,2)-E)^2+(lag(N,2)-N)^2),   # distance to pos -2 minutes
    nMinus1 = sqrt((lag(E,1)-E)^2+(lag(N,1)-N)^2),   # distance to pos -1 minutes
    nPlus1  = sqrt((E-lead(E,1))^2+(N-lead(N,1))^2), # distance to pos +1 mintues
    nPlus2  = sqrt((E-lead(E,2))^2+(N-lead(N,2))^2),  # distance to pos +2 minutes
    nPlus3 = sqrt((E-lead(E,3))^2+(N-lead(N,3))^2),   # distance to pos -3 minutes
    nPlus4 = sqrt((E-lead(E,4))^2+(N-lead(N,4))^2),   # distance to pos -4 minutes
    nPlus5 = sqrt((E-lead(E,5))^2+(N-lead(N,5))^2),   # distance to pos -5 minutes
  )


tracks <- tracks %>%
  rowwise() %>%
  mutate(
    stepMean = mean(c(nMinus5,nMinus4,nMinus3,nMinus2, nMinus1,nPlus1,nPlus2,nPlus3,nPlus4, nPlus5))) %>%
  ungroup()
#create boxplot 
ggplot(tracks,na.rm= TRUE)+
  geom_boxplot(mapping = aes(stepMean))

#create histogramm
ggplot(tracks,na.rm= TRUE)+
  geom_histogram(mapping = aes(stepMean))

##all points which are bigger than the mean of stepMean are defined as static (moving)

tracks <- tracks %>% 
  ungroup() %>%
  mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

#create a new dataframe with filterd 
tracks_filter <- tracks %>%
  filter(!static)

tracks_filter%>%
  ggplot(aes(E, N, col=as.factor(activity_ID)))  +
  geom_path() +
  geom_point() +
  coord_fixed() +
  theme(legend.position = "botton")
  #facet_wrap(~activity_ID)

#plot trajectories with behaviour pattern (static/moving) for Athlete 01 

tracks%>%
  ggplot(aes(E, N))  +
  geom_path() +
  geom_point(aes(colour = static)) +
  theme(legend.position = "right")+
  facet_wrap(~activity_ID)+
  ggtitle("Athlete_01")



```

# 5.2 heart rate 

# model 

Multimodel Inference

```{r}
if(!require(MuMIn)){install.packages("MuMIn")}
library(MuMIn)
library(gridExtra)

global.model <- lm(zf$time ~ 0 + zf$distance + zf$hightdiff_up + zf$hightdiff_down, data=zf)
options(na.action="na.fail")
allmodels <- dredge(global.model)
allmodels

importance(allmodels)

avgmodel<-model.avg(get.models(dredge(global.model,rank="AICc"),subset=TRUE))
summary(avgmodel)

# Komischerweise ist das "drittbeste Modell" einiges genauer als das beste Modell...
distance_param <- allmodels$`zf$distance`[3]
up_param <- allmodels$`zf$hightdiff_up`[3]
down_param <- allmodels$`zf$hightdiff_down`[3]

zf$time_estimated <- zf$distance *distance_param + zf$hightdiff_up * up_param + zf$hightdiff_down * down_param

zf %>% 
  select(activity_ID, time_measured = time, time_estimated, distance, hightdiff_up, hightdiff_down) %>%
  gather(type, value, time_measured, time_estimated) %>%
  ggplot(aes(distance, value, col = type)) +
  geom_point() +
  geom_line() +
  geom_text(aes(y = max(zf$time) + 15, label = paste("Dist:", round(distance/1000,1), "km"))) +
  geom_text(aes(y = max(zf$time) + 10, label = paste("Aufw.:", round(hightdiff_up,0), "m"))) +
  geom_text(aes(y = max(zf$time) + 5, label = paste("Abw.:", -round(hightdiff_down,0), "m"))) +
  theme_bw() +
  labs(x = "\nAktivitäts-ID", y = "Zeitbedarf in min\n")

zf %>% 
  select(activity_ID, time_measured = time, time_estimated, distance, hightdiff_up, hightdiff_down) %>%
  gather(type, value, time_measured, time_estimated) %>%
  ggplot(aes(distance, value, col = type)) +
  geom_point() +
  geom_smooth()
```

#validation


```{r}

```

