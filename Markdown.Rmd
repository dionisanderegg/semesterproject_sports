---
title: "Markdown"
author: "Alissa Tophinke, Dionis Anderegg"
date: "27 Mai 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

#1 Data Preparation 
## 1.1 Load packages

load Packages :
```{r, message = FALSE}
library(rgdal) 
library(sf)
library(tidyverse)
library(lubridate)
library(zoo)
library(purrr)
library(base)

if(!requireNamespace("remotes")) {
    install.packages("remotes")
}
remotes::install_github("grimbough/FITfileR")

library(FITfileR)
library(gdata)
library(plotly)
```

## 1.2 Import data

Import all files with extension .fit from the R project folder and merge them into a single Data.frame. Delete all other Data.frames so that only the entire DF is in the workspace. Various calculations have to be done only once (timelag, distance etc.).

```{r message=TRUE, warning=FALSE}
myfiles <- list.files(".",pattern = "*.fit")

for (i in 1:length(myfiles)) {
  varName <- paste0("temp", i, ".fit")
  assign(varName, as.data.frame(records(readFitFile(myfiles[i]))))
}

#generate dataframe "full" with all data

full <- mget(ls(pattern="temp")) %>%
              bind_rows()

keep(full, sure = TRUE)

#check full
head(full)
```
## 1.3 evaluate altitude with DEM 

```{r}
#digital elevation model to verify altitude for each GPS location
# ATTENTION: This part of the code only works, if seperate R-Script "import.multiple.DHM.R"
#  was runned bevore => Conttains the elevation for every 2x2 m point in canton of SG.
# DHM contains all even points in x and y => round
full_sf$x_round <- as.numeric(2 * round(full_sf$x/2) + 1)  
full_sf$y_round <- as.numeric(2 * round(full_sf$y/2) + 1)

# filter DHM source (other huge data.frame by specific research area)
DHM_filter <- data.matrix %>%
  filter(x_round > min(full_sf$x_round, na.rm = TRUE) - 2,
         x_round < max(full_sf$x_round, na.rm = TRUE) + 2,
         y_round > min(full_sf$y_round, na.rm = TRUE) - 2,
         y_round < max(full_sf$y_round, na.rm = TRUE) + 2)

# Join elevation 
full_sf_join <- left_join(full_sf, DHM_filter, by = c("x_round", "y_round"))
full_sf_join$altitude_diff <- full_sf_join$layer - full_sf_join$enhanced_altitude

# Test accuracy of elevation measurement
full_sf_join %>%
  gather(source, value, enhanced_altitude, layer) %>%
  filter(activity_ID < 10) %>%
  ggplot(aes(timestamp, value, col = source)) +
  geom_line() +
  facet_wrap(~activity_ID, scales = "free") +
  theme_bw()+
  labs(x = "\ntimestamp hh:mm", y = "altitude measurement m a.s.l.\n")+
  theme(legend.position = "bottom")

full_sf_join %>%
  filter(activity_ID < 10) %>%
  ggplot(aes(timestamp, altitude_diff)) +
  geom_line() +
  facet_wrap(~activity_ID, scales = "free") +
  theme_bw() +
  labs(x = "\ntimestamp hh:mm", y = "altitude difference (DEM - Tracker) in m\n")

```



## 1.4 add variables 

Calculate speed and timelags. Activities must be able to be grouped. This is done via the "activity_ID", which segments the data frame into individual tracks.
For the distance between two GPS fixes a SF object must be created and converted to the format CH1903+ LV95. From this the distance can be calculated.

### 1.4.1 calculate timelag

```{r}
# Calculate timelag
full$timelag <- as.integer(difftime(full$timestamp, lag(full$timestamp)))
# activity_ID (new ID if timelag > 1 hour)
full$activity_conter <- ifelse(abs(full$timelag) > 3600, TRUE, FALSE) 
full$activity_conter[1] <- TRUE  # ID 1 = TRUE, as this is activity one
full$activity_ID <- cumsum(full$activity_conter == TRUE)  # create acitiviy_ID based on counter

```

### 1.4.2 calculate speed / add rollmean function
```{r}
# speed from tracker in km/h
full$enhanced_speed_kmh <- full$enhanced_speed *3.6

# smooth speed and heart rate by rollmenans
full <- full %>%
  group_by(activity_ID) %>%
  mutate(
    enhanced_speed_03 = rollmean(enhanced_speed_kmh, k = 3, fill = NA, allign = "left"),
    enhanced_speed_05 = rollmean(enhanced_speed_kmh, k = 5, fill = NA, allign = "left"),
    enhanced_speed_10 = rollmean(enhanced_speed_kmh, k = 10, fill = NA, allign = "left"),
    enhanced_speed_15 = rollmean(enhanced_speed_kmh, k = 15, fill = NA, allign = "left"),
    enhanced_speed_30 = rollmean(enhanced_speed_kmh, k = 30, fill = NA, allign = "left"),
    enhanced_speed_60 = rollmean(enhanced_speed_kmh, k = 60, fill = NA, allign = "left")
  )

# How "k-value" affects the variety in speed:
full %>%
  filter(activity_ID == 2) %>%
  gather(smoother, speed, enhanced_speed_kmh, enhanced_speed_03 : enhanced_speed_60) %>%
  ggplot(aes(timestamp, speed, col = smoother)) +
  geom_line() +
  theme_bw()
ggplotly()

# Create sf and convert to CH1903+ LV95 to calculate the euculidian distance
full_sf <- st_as_sf(full, coords = c("position_long", "position_lat"),
         crs = 4326)
full_sf <- st_transform(full_sf, crs = 2056)

options(digits = 3)

# get x and y coordinates from sf geometry
full_sf$x <- st_coordinates(full_sf$geometry)[,1]
full_sf$y <- st_coordinates(full_sf$geometry)[,2]

# calculate Euclidian steplength
full_sf <- full_sf %>%
  group_by(activity_ID) %>%
  mutate(
    steplength = sqrt((x - lead(x))^2 + (y - lead(y))^2),
    steplenght_sum = cumsum(replace_na(steplength,0)),
    hightdiff = lead(enhanced_altitude) - enhanced_altitude,
    hightdiff_up = ifelse(hightdiff > 0, hightdiff, 0),
    hightdiff_down = ifelse(hightdiff < 0, hightdiff, 0)
  )

# How altitude differences up affect speeds
full_sf %>%
  filter(activity_ID == 2) %>%
  ggplot(aes(timestamp, enhanced_speed_15)) +
  geom_line()+
  geom_line(aes(y = rollmean(hightdiff_up, k = 15, fill = NA, allign = "left")*10), col = "green3") +
  scale_y_continuous(
    "speed\n", 
    sec.axis = sec_axis(~ . * 0.1, name = "hight difference\n")
  )+
  theme_bw()
ggplotly()

# How altitude differences down affect speeds
full_sf %>%
  filter(activity_ID == 2) %>%
  ggplot(aes(timestamp, enhanced_speed_15)) +
  geom_line()+
  geom_line(aes(y = rollmean(-hightdiff_down, k = 15, fill = NA, allign = "left")*10), col = "green4") +
  scale_y_continuous(
    "speed\n", 
    sec.axis = sec_axis(~ . * 0.1, name = "hight difference\n")
  ) +
  theme_bw()
ggplotly()

#compare distance and steplength_sum

full_sf %>%
  filter(activity_ID < 7) %>%
  ggplot() +
  geom_point(aes(timestamp, distance, col = "measurement")) +
  geom_point(aes(timestamp, steplenght_sum, col = "euclidian distance")) +
  theme_bw() +
  theme(legend.position = "bottom") +
  facet_wrap(~activity_ID, scales = "free") +
  labs(x = "\n time", y = "distance in meters\n")
```
Die Grafik zeigt, dass die Distanz aus dem .fit-File sehr nahe an der berechneten Distanz liegt.
Weiter mit den Daten von der .fit Datei???


# 2 Explorative data analysis 

Datenanalyse eines einzelnen Tracks

Folgend wird grafisch aufgezeigt, wie sich die Variablen Geschwindigkeit, Höhendifferenz und Herzfrequenz verhalten.
```{r}
full_long <- gather(full, type, value, enhanced_altitude:heart_rate, enhanced_speed_kmh)

full_long %>%
  filter(activity_ID == 1) %>%
  ggplot(aes(timestamp, value, col = type)) +
  geom_line()+
  geom_point() +
  facet_wrap(~type, scales = "free",ncol = 1) +
  theme_bw() +
  theme(legend.position = "none") +
  labs(x = "\nUhrzeit in hh:mm", y = "Wert\n")
```

In der Tendenz lässt sich visuell eine Abnahme der Geschwindigkeit und eine Zunahme der Herzfrequenz mit einem Höhenanstieg erkennen. Ausserdem ist eine Pause von ca. 10 minuten duetlich am Geschwindigkeitdiagramm zu erkennen.

## 2.1 General overview => Lenths, times, hightdifferences...

## 2.2 Analyse some tracks and show them on map (interactive?)

## 2.3 Possible outliers and evaluation area (scope)?

# 3 Map visualizations

Tracks auf Karten darstellen (verschiedene Packages und Methoden). Welche Packages eignen sich?

## visualization without maps

ggplot:
```{r, message=FALSE}
# Visualisierung mit ggplot ohne Karte
library(tidyverse)
ggplot(filter(full, enhanced_speed_kmh > 4), aes (position_lat, position_long, col = enhanced_speed_kmh)) +
  geom_point() +
  facet_wrap(~activity_ID, scales = "free") +
  theme_bw()
```

Bei einigen Tracks scheint es noch ein Problem mit den Daten zu geben. = Siehe obiger Plot.

##visualization with leaflet

Leaflet ist interaktiv (m.E. sehr cool ;)) aber weniger einfach zu bearbeiten als ggplot oder ggmap (facets und einfärben von Datenpunkten etc.).
```{r, message = FALSE}
# Visualiseriung mit leaflet() => Interaktiv, schwer zu bearbeiten
library(leaflet)

# Track 1
m1 <- full %>%
  filter(activity_ID ==1) %>%
  select(position_long, position_lat) %>% 
  as.matrix() %>%
  leaflet(  ) %>%
  addTiles() %>%
  addPolylines( )
m1

# Track 2
m2 <- full %>%
  filter(activity_ID ==2) %>%
  select(position_long, position_lat) %>% 
  as.matrix() %>%
  leaflet(  ) %>%
  addTiles() %>%
  addPolylines( )
m2
```


ggmap() => Da die Karten importiert werden müssen nur für 3 Tracks gezeigt:
```{r, message = FALSE}
# Visualiserung mit ggmap
track1_3 <- full %>%
  filter(activity_ID < 4)

library(ggmap)

myLocation <- c(min(track1_3$position_long), min(track1_3$position_lat), 
                max(track1_3$position_long), max(track1_3$position_lat))  # Position definieren für Karten

myMap <- get_stamenmap(bbox=myLocation, maptype="terrain", crop=TRUE, zoom = 13)  # Kartenimport

ggmap(myMap) +
  geom_point(data = filter(track1_3, enhanced_speed_kmh > 3), 
             aes(position_long,position_lat, col = enhanced_speed_kmh)) +
  facet_wrap(~activity_ID) +
  labs(x = "\nLängengrad [°E]", y = "Breitengrad [°N]\n")
```


# 4 Zusammenfassung pro Track
```{r}
zf <- full_sf %>%
  st_drop_geometry() %>%
  group_by(activity_ID) %>%
  summarise(
    date = date(timestamp[1]),
    distance = max(distance, na.rm = TRUE),
    time = as.numeric(difftime(max(timestamp), min(timestamp), units = "mins")),
    hightdiff_up = sum(hightdiff_up, na.rm = TRUE),
    hightdiff_down = sum(hightdiff_down, na.rm = TRUE),
    mean_pace = time / distance * 1000
    )
```


# 5 Behaviour pattern

## 5.1 Pauses and Movement

## 5.2 Heart rates

```{r}

```


# model 

## Model basis => Segmeentation of all Tracks 
```{r}
full_sf_min <- full_sf %>%
  st_drop_geometry() %>%
  group_by("time" = cut(timestamp, "1 min")) %>%
  summarise(
    distance = sum(steplength, na.rm = TRUE),
    hightdiff_up = sum(hightdiff_up, na.rm = TRUE),
    hightdiff_down = sum(hightdiff_down, na.rm = TRUE),
    hightdiff_balance = hightdiff_up + hightdiff_down,
    time_eff = sum(timelag, na.rm = TRUE),
    mean_pace = time_eff / distance * 1000 / 60
  ) %>%
  mutate(vertical_direction = ifelse(hightdiff_balance > 2, "up",
                                      ifelse(hightdiff_balance < -2, "down",
                                             "horizontal")))

full_sf_min <- full_sf_min %>%
  filter(time_eff < 100, time_eff > 0, mean_pace < 25)
```


Multimodel Inference for zf.model

```{r}
if(!require(MuMIn)){install.packages("MuMIn")}
library(MuMIn)
library(gridExtra)

zf.model <- lm(zf$time ~ 0 + zf$distance + zf$hightdiff_up + zf$hightdiff_down, data=zf)
options(na.action="na.fail")
allmodels.zf <- dredge(zf.model)
allmodels.zf

importance(allmodels.zf)

avgmodel.zf<-model.avg(get.models(dredge(zf.model,rank="AICc"),subset=TRUE))
summary(avgmodel.zf)

# Komischerweise ist das "drittbeste Modell" einiges genauer als das beste Modell...
distance_param <- allmodels.zf$`zf$distance`[3]
up_param <- allmodels.zf$`zf$hightdiff_up`[3]
down_param <- allmodels.zf$`zf$hightdiff_down`[3]

zf$time_estimated <- zf$distance *distance_param + zf$hightdiff_up * up_param + zf$hightdiff_down * down_param

zf %>% 
  select(activity_ID, time_measured = time, time_estimated, distance, hightdiff_up, hightdiff_down) %>%
  gather(type, value, time_measured, time_estimated) %>%
  ggplot(aes(distance, value, col = type)) +
  geom_point() +
  geom_line() +
  geom_text(aes(y = max(zf$time) + 15, label = paste("Dist:", round(distance/1000,1), "km"))) +
  geom_text(aes(y = max(zf$time) + 10, label = paste("Aufw.:", round(hightdiff_up,0), "m"))) +
  geom_text(aes(y = max(zf$time) + 5, label = paste("Abw.:", -round(hightdiff_down,0), "m"))) +
  theme_bw() +
  labs(x = "\nAktivitäts-ID", y = "Zeitbedarf in min\n")

zf %>% 
  select(activity_ID, time_measured = time, time_estimated, distance, hightdiff_up, hightdiff_down) %>%
  gather(type, value, time_measured, time_estimated) %>%
  ggplot(aes(distance, value, col = type)) +
  geom_point() +
  geom_smooth()
```


Multimodel Inference for min.model

```{r}
min.model <- lm(time_eff/60 ~ 0 + distance + hightdiff_up + hightdiff_down, data=full_sf_min)
options(na.action="na.fail")
allmodels.min <- dredge(min.model)
allmodels.min   # model[1] makes more sence than zf.model!
# Interpretation: Per meter of Distance 0.00461 minutes, per meter up 0.035 minutes
#  per meter down 0.01 minutes (negative because hightdiff_down is negative!).

importance(allmodels.min)

avgmodel.min<-model.avg(get.models(dredge(min.model,rank="AICc"),subset=TRUE))
summary(avgmodel.min) # All predictors are highli significant!

# Komischerweise ist das "drittbeste Modell" einiges genauer als das beste Modell...
distance_param_min <- allmodels.min$distance[1]
up_param_min <- allmodels.min$hightdiff_up[1]
down_param_min <- allmodels.min$hightdiff_down[1]

zf$time_estimated_min <- zf$distance *distance_param_min + zf$hightdiff_up * up_param_min + zf$hightdiff_down * down_param_min

zf %>% 
  select(activity_ID, time_measured = time, time_estimated, time_estimated_min, distance, hightdiff_up, hightdiff_down) %>%
  gather(type, value, time_measured, time_estimated, time_estimated_min) %>%
  ggplot(aes(activity_ID, value, col = type)) +
  geom_point() +
  geom_line() +
  theme_bw() +
  labs(x = "\nAktivitäts-ID", y = "Zeitbedarf in min\n")

zf %>% 
  select(activity_ID, time_measured = time, time_estimated_min, distance, hightdiff_up, hightdiff_down) %>%
  gather(type, value, time_measured, time_estimated_min) %>%
  ggplot(aes(distance, value, col = type)) +
  geom_point() +
  geom_smooth(method = "lm") +
  theme_bw()
# It seems that the model underestimates time requirement for long distances, and overestimates
#  for short distances => Exhaution!

# Show the pace-dependency of the hightdifference up
full_sf_min %>%
  filter(vertical_direction == "up") %>%
  ggplot(aes(hightdiff_up, mean_pace)) +
  geom_point() +
  geom_smooth(span = 1) +
  ylim(4.3,14.5) +
  theme_bw() +
  labs(x = "\nhightdifference up per minute of running time", y = "mean pace per minute of running time\n")

full_sf_min %>%
  filter(vertical_direction == "down") %>%
  ggplot(aes(-hightdiff_down, mean_pace)) +
  geom_point() +
  geom_smooth(span = 1) +
  ylim(4.4,11) +
  xlim(0,38) +
  theme_bw() +
  labs(x = "\nhightdifference down per minute of running time", y = "mean pace per minute of running time\n")

ggplot(full_sf_min, aes(mean_pace, hightdiff_down)) +
  geom_point()

```

#validation


```{r}

```

